# Here Be Dragons:<br/>Elegant & Ugly<br/>Hacks in CPython

# Presenter Notes

* Get started!

---

# Why isn't<br/>all code<br/>beautiful?

# Presenter Notes

* why are there hacks in CPython? why talk about them?
* there's a lot of material out there providing advice on writing code well
* learning to write code well is only part of the story
* exploring some of CPython's nooks and crannies can help illuminate some of
  the harder to articulate aspects of software design

---

# Do the simplest<br/>thing that could<br/>possibly work

# Presenter Notes

* one key step is learning when not to write code at all
* there are lots of reasons to write code, including just for the fun of it
* but when you're trying to solve a specific problem, code is the enemy
  and you want as little of it in your solution as possible

---

# Customising<br/>Syntax Errors<br/>(Demo)

# Presenter Notes

* Demo 01!
* most syntax errors generated by the parser, based on the Grammar file
* just a generic message, and where the parser got confused

---

# My first answer:<br/>change the grammar

# Presenter Notes

* The most comprehensive way to generate better custom error messages
  is to let them through the parser and handle them later when we have
  more information
* We do that with several of Python's more complex conditions (like requiring
  that break and continue only appear in loops)
* I actually wrote the code to do this for print and exec based on an
  earlier patch I wrote allowing implicit call statements

---

# Guido's<br/>better answer:<br/>`SyntaxError_init`

# Presenter Notes

* Changing the Grammar is a high risk activity, with broad impact
* SyntaxError constructor can see the text that confused the parser
* Perhaps we could check for suspicious looking operations there and change
  the error message if it looked like print was being used as a statement

---

# From `exceptions.c`:

    !c
    /* Issue #21669: Custom error for 'print' & 'exec' */
    if (self->text && PyUnicode_Check(self->text)) {
        if (_report_missing_parentheses(self) < 0) {
            return -1;
        }
    }

# Presenter Notes

* And here it is
* Include issue references for "weird" code. Gives pointers to context.
* Still use good coding practices, even when the objective is a bit odd
* "_report_missing_parentheses" has a big block comment above it

---

# Buying time with<br/>"80% solutions"

# Presenter Notes

* Another case of not writing code arises when facing a really hard problem
* sometimes you can solve a simpler problem much faster, and put off
  solving the hard problem for the time being
* it may turn out the hard problem didn't need solving, or someone else
  may solve it first

---

# Decorators and<br/>wrapper functions<br/>(Demo)

# Presenter Notes

* Demo 03!
* Bad introspection info in decorators - reported wrapper location, not
  decorated function
* Wanted to improve that situation for Python 2.5

---

# functools.wraps<br/>September 2006<br/><br/>wrapt.decorator<br/>September 2013

# Presenter Notes

* Copying attributes is a brute force hack
* I'll take 7 years as a win :)
* Also avoids some subtle issues with shared function attributes

---

# Nudge users in<br/>(hopefully)<br/>helpful directions

# Presenter Notes

* one of the biggest problems in interface design is helping people to see
  what to do next, or even how to get back to where they were before
* this is particularly bad in command line applications
* pico and nano are still better at this than most other text apps

---

# Let me out!<br/>(Demo)

# Presenter Notes

* one problem with the default Python REPL is the lack of an obvious way to
  exit
* for a long time, typing quit or exit at the prompt just gave a function
  repr
* we came up with something better
* Demo 03!

---

# Use simple components

# Presenter Notes

* Python has some rich metaprogramming capabilities
* Dynamic type creation, metaclasses, AST based metaprogramming
* Don't use them if you can possibly avoid it
* Treat them as an absolute last resort, as using any of them creates an
  immediate maintainability problem

---

# Implementing a<br/>type factory<br/>(Demo)

# Presenter Notes

* a complaint we sometimes hear is "I love namedtuple, but I hate how it's
  implemented"
* why might that be?
* Demo 04!

---

# Keep technical debt<br/>under control!

# Presenter Notes

* Don't take this as a recommendation to ship broken software
* Good tests, good comments, design and code review are even *more*
  important when taking shortcuts or you'll end up with an unmaintainable
  mess
* Refactor ruthlessly - recognise when you've hit the limits of a shortcut,
  and take the time to pay down the technical debt

---

# Q & A

* @ncoghlan_dev on Twitter
* CPython core developer
* PSF director
* Red Hat toolsmith
